[{"title":"2018愿你做最美好的自己！","date":"2018-02-22T12:21:12.000Z","path":"2018/02/22/2018写给自己/","text":"转眼一年又过去了，2018送给自己八封信，愿时光轻缓，愿微风正好，愿你做最美好的自己。 第一封 —— 关于压力 鸡蛋，从外打破是食物，从内打破是生命。人生亦是，从外打破是压力，从内打破是成长。如果你等待别人打破你，那么你注定成为别人的食物；如果能让自己从内打破，那么你会发现自己的成长相当于一种重生。 第二封 —— 关于读书 读书是一种充实人生的艺术，没有书的人生就像空心的竹子一样，空洞无物。犹太人让孩子们亲吻涂有蜂蜜的书本，是为了让他们记住：书本是甜的，要让甜蜜充满人生就要读书。读书是一本人生最难得的存折，一点一滴地积累，最后你会发现：自己是世界上最富有的人。 第三封 —— 关于人际关系 你可以要求自己守信，但不能要求别人守信；你可以要求自己对人好，但不能期待别人对你好。你怎样对人，并不代表人家就会怎么对你。如果看不透这一点，你只会徒添不必要的烦恼。 第四封 —— 关于孤独 每个人都要经历一段孤独的日子，每段路都有一段独孤的时光。父母不可能一直帮着你，朋友也不可能一直围着你转。孤独不是孤僻，更不是寂寞。经历过孤独的人，内心更坚强，不管处于什么样的环境都能让自己安静，更好地调整状态，面对环境。 第五封 —— 关于修养 看别人不顺眼，是自己修养不够。人愤怒的那一瞬间，智商是零，过一分钟后恢复正常。人的优雅关键在于控制自己的惰绪，用嘴伤害人，是最愚蠢的一种行为。 第六封 —— 关于现实 现实有太多的不如意，就算生活给你的是垃圾，你同样能把垃圾踩在脚底下登上世界之巅。你要把自己逼出最大的潜能，没有人会为你的未来买单，你要么努力向上爬，要么烂在社会最底层的泥里，这就是生活。 第七封 —— 关于自己 一个人经过不同程度的鍛炼，就获得不同程度的修养。好比香料，捣得愈碎，磨得愈细，香得愈浓烈。我们曾如此渴望命运的波澜，到最后才发现：人生最曼妙的风景，竟是内心的淡定与从容。我们曾如此期盼外界的认可，到最后才知道：世界是自己的，与他人毫无关系。 第八封 —— 关于幸福 常有人说，我现在不幸福，等我结了婚或买了房……就幸福了。事实是，幸福的人在哪儿都幸福，不幸福的人在哪儿都不幸福。所以要先培养自己的幸福力，不论发生什么，别人都动不了你的自在开心。这才是真正强大的气场和自信。 幸福的人生，需要三种姿态：对过去，要淡；对现在，要惜；对未来，要信。愿你拥有幸福的能力，做最美好的自己。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"浅谈快速开发的一些思考（四）异常处理","date":"2017-12-22T13:21:12.000Z","path":"2017/12/22/浅谈快速开发的一些思考（四）异常处理/","text":"通常在业务代码中我是不需要进行异常处理，我们只定义异常，然后在web层统一处理系统异常和业务异常，这样也方便我去做一些统一的返回的处理，也减少我们的工作量。 123456789101112131415161718192021222324252627282930313233@RestControllerAdvicepublic class ApiExceptionHandler &#123; private Logger logger = LoggerFactory.getLogger(getClass()); /** * 自定义异常 */ @ExceptionHandler(ApiException.class) public ApiResult handleApiException(ApiException e)&#123; if (e.getCode() == -1)&#123; return ApiResult.noLogin(); &#125; logger.error(e.getMessage(), e); return ApiResult.error(e.getCode(),e.getMessage()); &#125; @ExceptionHandler(DuplicateKeyException.class) public ApiResult handleDuplicateKeyException(DuplicateKeyException e)&#123; logger.error(e.getMessage(), e); return ApiResult.error(\"数据库中已存在该记录\"); &#125; @ExceptionHandler(NullPointerException.class) public ApiResult handleNullException(NullPointerException e)&#123; logger.error(e.getMessage(), e); return ApiResult.error(\"数据处理异常\"); &#125; @ExceptionHandler(Exception.class) public ApiResult handleException(Exception e)&#123; logger.error(e.getMessage(), e); return ApiResult.error(e.getMessage()); &#125;&#125; 在上面的这个类上我们进行统一的异常处理，来解析和返回响应","tags":[{"name":"技术杂谈","slug":"技术杂谈","permalink":"http://yoursite.com/tags/技术杂谈/"}]},{"title":"浅谈快速开发的一些思考（三）aop规范","date":"2017-12-17T13:21:12.000Z","path":"2017/12/17/浅谈快速开发的一些思考（三）aop规范/","text":"说道spring就不得不说一说spring aop，真的是一大利器呀.AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。 使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 AOP核心概念1、横切关注点 对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点 2、切面（aspect） 类是对物体特征的抽象，切面就是对横切关注点的抽象 3、连接点（joinpoint） 被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器 4、切入点（pointcut） 对连接点进行拦截的定义 5、通知（advice） 所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类 6、目标对象 代理的目标对象 7、织入（weave） 将切面应用到目标对象并导致代理对象创建的过程 8、引入（introduction） 在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段 Spring对AOP的支持Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理。因此，AOP代理可以直接使用容器中的其它bean实例作为目标，这种关系可由IOC容器的依赖注入提供。Spring创建代理的规则为： 1、默认使用Java动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了 2、当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理，也可强制使用CGLIB AOP编程其实是很简单的事情，纵观AOP编程，程序员只需要参与三个部分： 1、定义普通业务组件 2、定义切入点，一个切入点可能横切多个业务组件 3、定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作 所以进行AOP编程的关键就是定义切入点和定义增强处理，一旦定义了合适的切入点和增强处理，AOP框架将自动生成AOP代理，即：代理对象的方法=增强处理+被代理对象的方法。 废话不多说了直接上我项目中用到的aop 12345678910111213141516171819202122232425262728//线程变量用于记录线程内变量来计算内部响应时间ThreadLocal&lt;Long&gt; startTime = new ThreadLocal&lt;&gt;();@Pointcut(\"execution(public * com.demo.controller..*.*(..))\")public void webLog()&#123;&#125;@Before(\"webLog()\")public void doBefore(JoinPoint joinPoint) throws Throwable &#123; // 记录下请求内容 logger.info(\"CLASS_METHOD : &#123;&#125;\",joinPoint.getSignature().getDeclaringTypeName() + \".\" + joinPoint.getSignature().getName()); Object[] args = joinPoint.getArgs(); logger.info(\"ARGS : &#123;&#125;\" ,Arrays.toString(args)); //处理参数校验错误 for (Object arg : args) &#123; if (arg instanceof BindingResult)&#123; BindingResult bindingResult = (BindingResult) arg; if (bindingResult.hasErrors())&#123; throw new ApiException(ValidateUtil.toStringJson(bindingResult), ApiResult.VALIDATE); &#125; &#125; &#125; startTime.set(System.currentTimeMillis());&#125;@AfterReturning(returning = \"ret\", pointcut = \"webLog()\")public void doAfterReturning(Object ret) throws Throwable &#123; // 处理完请求，返回内容 logger.info(\"response : &#123;&#125;\" , ret); logger.info(\"spendTime : &#123;&#125;\",(System.currentTimeMillis() - startTime.get())); startTime.remove();&#125; 上面的日志只处理进入我们的controller之前的日志记录，所以这些日志记录的都是我们定好的接口访问日志，如果想记录比较完备的request请求信息建议使用interceptor连记录 12345@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; logger.info(\"request:&#123;&#125;\", RequestUtils.dump(request)); return super.preHandle(request, response, handler);&#125; 123456789101112131415161718192021222324252627282930313233343536public static String dump(HttpServletRequest request) throws Exception &#123; HashMap&lt;String, Object&gt; hashMap = new LinkedHashMap&lt;&gt;(); hashMap.put(\"url\", request.getRequestURL()); hashMap.put(\"method\", request.getMethod()); hashMap.put(\"remoteAddr\", request.getRemoteAddr()); hashMap.put(\"remoteHost\", request.getRemoteHost()); Cookie[] cookies = request.getCookies(); if (cookies != null) &#123; Object[] cookieArray = new Object[cookies.length]; for (int i = 0; i &lt; cookies.length; i++) &#123; Cookie cookie = cookies[i]; HashMap&lt;String, Object&gt; cookieMap = new HashMap&lt;&gt;(); cookieMap.put(\"name\", cookie.getName()); cookieMap.put(\"value\", cookie.getValue()); cookieMap.put(\"maxAge\", cookie.getMaxAge()); cookieMap.put(\"path\", cookie.getPath()); cookieArray[i] = cookieMap; &#125; hashMap.put(\"cookies\", cookieArray); &#125; Map&lt;String, String&gt; parameters = new HashMap&lt;&gt;(); request.getParameterMap().entrySet().parallelStream().forEach(e -&gt; &#123; String valueStr = Arrays.toString(e.getValue()); parameters.put(e.getKey(), valueStr.substring(0, Math.min(64, valueStr.length()))); &#125;); hashMap.put(\"parameters\", parameters); HashMap&lt;String, Object&gt; headerMap = new LinkedHashMap&lt;&gt;(); Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); while (headerNames.hasMoreElements()) &#123; String name = headerNames.nextElement(); String value = request.getHeader(name); headerMap.put(name, value); &#125; hashMap.put(\"headers\", headerMap); return JSONObject.toJSONString(hashMap);&#125; 这样我们就完成了对于请求日志记录，方法调用日志的记录，同时还进行了通用的参数校验参数校验其实同样很简单，springboot默认就集成了参数校验 12345678/** * 添加用户2 * @param userInfo */@PostMapping(\"/createUser2\")public String createUser2(@Valid UserInfo userInfo, BindingResult bindingResult)&#123; return \"OK\";&#125; 这样我们的aop就可以通过解析我们上面的bindingResult来进行统一的参数校验了下面是一些常见的校验注解@null 验证对象是否为空 @notnull 验证对象是否为非空 @asserttrue 验证 boolean 对象是否为 true @assertfalse 验证 boolean 对象是否为 false @min 验证 number 和 string 对象是否大等于指定的值 @max 验证 number 和 string 对象是否小等于指定的值 @decimalmin 验证 number 和 string 对象是否大等于指定的值，小数存在精度 @decimalmax 验证 number 和 string 对象是否小等于指定的值，小数存在精度 @size 验证对象（array,collection,map,string）长度是否在给定的范围之内 @digits 验证 number 和 string 的构成是否合法 @past 验证 date 和 calendar 对象是否在当前时间之前 @future 验证 date 和 calendar 对象是否在当前时间之后 @pattern 验证 string 对象是否符合正则表达式的规则 @Email 验证邮箱 例如： 1234567891011121314@size (min=3, max=20, message=\"用户名长度只能在3-20之间\")@size (min=6, max=20, message=\"密码长度只能在6-20之间\")@pattern (regexp=\"[a-za-z0-9._%+-]+@[a-za-z0-9.-]+\\\\.[a-za-z]&#123;2,4&#125;\", message=\"邮件格式错误\")@Length(min = 5, max = 20, message = \"用户名长度必须位于5到20之间\") @Email(message = \"比如输入正确的邮箱\") @NotNull(message = \"用户名称不能为空\") @Max(value = 100, message = \"年龄不能大于100岁\") @Min(value= 18 ,message= \"必须年满18岁！\" ) @AssertTrue(message = \"bln4 must is true\")@AssertFalse(message = \"blnf must is falase\")@DecimalMax(value=\"100\",message=\"decim最大值是100\")@DecimalMin(value=\"100\",message=\"decim最小值是100\")@NotNull(message = \"身份证不能为空\") @Pattern(regexp=\"^(\\\\d&#123;18,18&#125;|\\\\d&#123;15,15&#125;|(\\\\d&#123;17,17&#125;[x|X]))$\", message=\"身份证格式错误\") 当然后台的参数校验是为了解决那些可以绕过前端校验的那些人才做的，也是为了提高系统的安全性和健壮性","tags":[{"name":"技术杂谈","slug":"技术杂谈","permalink":"http://yoursite.com/tags/技术杂谈/"}]},{"title":"浅谈快速开发的一些思考（二）controller规范","date":"2017-12-12T13:21:12.000Z","path":"2017/12/12/浅谈快速开发的一些思考（二）controller规范/","text":"Controller规范，主要的内容是就是接口定义里面的内容，你只要遵循里面的规范，controller就问题不大，除了这些，还有另外的几点： 所有函数返回统一的ResultBean格式原因在于统一的返回格式便于前端去进行通用的数据解析，也便于我们后台去进行一些统一的处理。 ResultBean是controller专用的，不允许往后传！ Controller做参数格式的转换，不允许把json，map这类对象传到services去，也不允许services返回json、map。 一般情况下！写过代码都知道，map，json这种格式灵活，但是可读性差，如果放业务数据，每次阅读起来都比较困难。定义一个bean看着工作量多了，但代码清晰多了。 参数中一般情况不允许出现Request，Response这些对象主要是可读性问题。一般情况下。 不需要打印日志，日志在AOP里面会打印，而且我的建议是大部分日志在Services这层打印。 参考一下我的ResultBean： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class ApiResult&lt;T&gt; &#123; public static final int SUCCESS = 0; public static final int NO_LOGIN = -1; public static final int NO_PERMISSION = -2; public static final int VALIDATE = 1; public static final int ERROR = 2; public static final String SUCCESS_MSG = \"success\"; public static final String ERROR_MSG = \"error\"; public static final String NO_LOGIN_MSG = \"no login\"; public static final String NO_PERMISSION_MSG = \"no perm\"; public static final String VALIDATE_MSG = \"validate fail\"; /** * 返回结果状态码 */ private int status; /** * 返回结果状态信息 */ private String msg; /** * 返回结果的数据 */ private T data; public static &lt;T&gt; ApiResult&lt;T&gt; success() &#123; return new ApiResult(); &#125; public static &lt;T&gt; ApiResult&lt;T&gt; error() &#123; return new ApiResult&lt;&gt;(ERROR, ERROR_MSG, null); &#125; public static &lt;T&gt; ApiResult&lt;T&gt; noLogin() &#123; return new ApiResult&lt;&gt;(NO_LOGIN, NO_LOGIN_MSG, null); &#125; public static &lt;T&gt; ApiResult&lt;T&gt; noPermission() &#123; return new ApiResult&lt;&gt;(NO_PERMISSION, NO_PERMISSION_MSG, null); &#125; public static &lt;T&gt; ApiResult&lt;T&gt; validate() &#123; return new ApiResult&lt;&gt;(VALIDATE, VALIDATE_MSG, null); &#125; public static &lt;T&gt; ApiResult&lt;T&gt; validate(String msg) &#123; return new ApiResult&lt;&gt;(VALIDATE, msg, null); &#125; public static &lt;T&gt; ApiResult&lt;T&gt; success(T data) &#123; return new ApiResult&lt;&gt;(SUCCESS, SUCCESS_MSG, data); &#125; public static &lt;T&gt; ApiResult&lt;T&gt; error(int code, String msg) &#123; return new ApiResult&lt;&gt;(code, msg, null); &#125; public static &lt;T&gt; ApiResult&lt;T&gt; error(String msg) &#123; return new ApiResult&lt;&gt;(ERROR, msg, null); &#125; public ApiResult() &#123; this.status = SUCCESS; this.msg = SUCCESS_MSG; this.data = null; &#125; public ApiResult(int status, String msg, T data) &#123; this.status = status; this.msg = msg; this.data = data; &#125;//setter getter tostring 统一的接口规范，能帮忙规避很多无用的返工修改和可能出现的问题。能使代码可读性更加好，利于进行aop和自动化测试这些额外工作。后面我会介绍基于aop的一些功能，如统一的参数校验，请求日志记录，响应时间统计，等等","tags":[{"name":"技术杂谈","slug":"技术杂谈","permalink":"http://yoursite.com/tags/技术杂谈/"}]},{"title":"浅谈快速开发的一些思考","date":"2017-12-10T13:21:12.000Z","path":"2017/12/10/浅谈快速开发的一些思考（一）序言/","text":"在公司开发，有很多时候我们需要独立去开发一些小的独立的项目，而且一般这种小的项目基本都是一个人来完成，但是往往我们去开发这些小的项目的时候希望可以快速的去将项目的整个框架搭建起来，不用过多去关注基础层的东西，而只需要去落实自己的业务代码和业务需求就可以了，今天就来总结一下自己对于快速搭建一个开发框架和基础代码编写的一些想法。关于技术选型来说，在java中，框架的集大成者莫过于spring了，spring在我看来一个是一个完备的java web项目的技术解决方案了，兼顾了灵活和强大功能了。关于spring框架的选择，我选择用spring boot来作为基础框架 why springbootSpring Boot让我们的Spring应用变的更轻量化。比如：你可以仅仅依靠一个Java类来运行一个Spring引用。你也可以打包你的应用为jar并通过使用java -jar来运行你的Spring Web应用。Spring Boot的主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 在我看来springboot就是springMVC+Tomcat嵌入式+一些针对第三方框架的整合starter，这是我理解的springboot 快速开启一个springboot1、通过SPRING INITIALIZR工具产生基础项目访问spring io提供了一个在线生成项目基础代码的工具，选择对应的版本然后点击Generate Project下载项目压缩包2、可以通过idea自带的项目初始化工具来进行项目的初始化，file-new project-spring INITIALIZR来选择版本信息和依赖信息 引入Web模块当前的pom.xml内容如下，仅引入了两个模块： spring-boot-starter：核心模块，包括自动配置支持、日志和YAML spring-boot-starter-test：测试模块，包括JUnit、Hamcrest、Mockito 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 引入Web模块，需添加spring-boot-starter-web模块： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 编写第一个web服务 创建package命名为com.demo.web（根据实际情况修改） 创建HelloController类，内容如下 123456789@RestControllerpublic class HelloController &#123; @RequestMapping(\"/hello\") public String index() &#123; return \"Hello World\"; &#125;&#125; 启动主程序，打开浏览器访问http://localhost:8080/hello，可以看到页面输出Hello World","tags":[{"name":"技术杂谈","slug":"技术杂谈","permalink":"http://yoursite.com/tags/技术杂谈/"}]},{"title":"MySQL 处理数据时的一些优化查询速度方法","date":"2017-10-20T13:21:12.000Z","path":"2017/10/20/MySQL 处理数据时的一些优化查询速度方法/","text":"在参与实际项目中，当 MySQL 表的数据量达到百万级时，普通的 SQL 查询效率呈直线下降，而且如果 where 中的查询条件较多时，其查询速度无法容忍。想想可知，假如我们查询淘宝的一个订单详情，如果查询时间高达几十秒，这么高的查询延时，任何用户都会抓狂。因此如何提高 SQL 语句查询效率，显得十分重要。 查询速度慢的原因 1、没有索引或者没有用到索引（这是查询慢最常见的问题，是程序设计的缺陷） 2、I/O 吞吐量小，形成了瓶颈效应。 3、没有创建计算列导致查询不优化。 4、内存不足 5、网络速度慢 6、查询出的数据量过大（可采用多次查询，其他的方法降低数据量） 7、锁或者死锁（这是查询慢最常见的问题，是程序设计的缺陷） 8、sp_lock,sp_who,活动的用户查看,原因是读写竞争资源。 9、返回了不必要的行和列 10、查询语句不好，没有优化 30 种 SQL 查询语句的优化方法： 1、应尽量避免在 where 子句中使用 != 或者 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。 2、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： 1select id from t where num is null; 可以在 num 上设置默认值 0 ，确保表中 num 列没有 null 值，然后这样查询： 1select id from t where num = 0; 3、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 4、尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： 1select id from t where num = 10 or num = 20; 可以这样查询： 123select id from t where num = 10union allselect id from t where num = 20; 5、下面的查询也将导致全表扫描：（不能前置百分号） 1select id from t where name like '%abc%'; 若要提高效率，可以考虑全文检索。6、in 和 not in 也要慎用，否则会导致全表扫描，如： 1select id from t where num in(1, 2, 3); 对于连续的数值，能用 between 就不要用 in 了： 1select id from t where num between 1 and 3; 12345select xx,phone FROM send a JOIN ( select '13891030091' phone union select '13992085916' ………… UNION SELECT '13619100234' ) b on a.Phone=b.phone--替代下面 很多数据隔开的时候in('13891030091','13992085916','13619100234'…………) 7、如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择到运行时；它必须在编译时进行选择。然而，如果在编译时简历访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： 1select id from t where num = @num; 可以改为强制查询使用索引： 1select id from t with(index(索引名)) where num = @num; 8、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： 1select id from t where num/2 = 100; 应改为： 1select id from t where num = 100 * 2; 9、应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： 12select id from t where substring(name, 1, 3) = ’abc’–name; //以abc开头的idselect id from t where datediff(day,createdate,’2005-11-30′) = 0–’2005-11-30′; //生成的id 应改为： 12select id from t where name like ‘abc%’select id from t where createdate &gt;= ’2005-11-30′ and createdate &lt; ’2005-12-1′; 10、不要在 where 子句中的 “=” 左边进行函数，算术运算或者其他表达式运算，否则系统将可能无法正确使用索引。 11、在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 12、对于大数据量的查询分页进行前置条件控制来提高查询速度，比如可以通过主键id来缩小范围然后limit.13、很多时候用 exists 代替 in 是一个好的选择： 1select num from a where num in(select num from b); 用下面的语句替换： 1select num from a where exists(select 1 from b where num=a.num); 14、并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段 sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。 15、索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 16、应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。 17、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 18、尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 19、任何地方都不要使用 select from t ，用具体的字段列表代替 ，不要返回用不到的任何字段。 20、尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。 21、避免频繁创建和删除临时表，以减少系统表资源的消耗。 22、临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 23、在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先 create table，然后 insert。 24、如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 25、尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 26、使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 27、与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 28、在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。 29、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 30、尽量避免大事务操作，提高系统并发能力。 查看sql的执行性能，explan 如： 1explain select * from t_order;","tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"spring-security初探","date":"2017-10-04T12:21:12.000Z","path":"2017/10/04/spring-security初探/","text":"对于后台开发来说权限控制是一个后台系统首要考虑的问题，通常来说安全框架的基本要素是认证、授权.所谓认证就是对你身份的认证，识别你这个人的身份，授权就是当你被认证之后对于访问某一资源是否具有相应的的角色或者权限，安全框架无非是围着这个两个核心的功能来搭建。那么问题来了，spring-security是怎么实现这一过程的呢? ##spring-security的工作流程 用户输入用户标识和密码，拦截器（springSecurityFilterChain）拦截用户的输入封装成UsernamePasswordAuthenticationToken。 身份认证器将上一步生成的UsernamePasswordAuthenticationToken，拿到用户名和密码之后进行认证，然后返回一个完整的认证信息，包括身份信息和角色权限信息。 SecurityContextHolder（上下文容器）将上一步的产生的身份信息存储起来（默认是存在ThreadLocal里面），这是一个简单的认证的过程，这个过程完成了身份认证的过程和权限信息的存储，后续进入后续的过滤器进行访问控制。##spring-security的几个核心类的源码分析Authentication1234567891011121314public interface Authentication extends Principal, Serializable &#123; //获取权限列表 Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); //获取密钥 Object getCredentials(); //获取认证的细节信息 Object getDetails(); //获取身份信息 Object getPrincipal(); //当前认证信息是否已经被认证 boolean isAuthenticated(); // 设置认证当前信息 void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;","tags":[{"name":"spring-security","slug":"spring-security","permalink":"http://yoursite.com/tags/spring-security/"}]},{"title":"hello blog","date":"2017-10-03T06:21:12.000Z","path":"2017/10/03/hello blog/","text":"一直想弄一个自己的博客，去写写自己喜欢的东西，去书写一些工作、学习、生活的琐事，也文字化一些自己在工作中遇到的坑点，努力让自己学着去总结去沉淀，不在以追求结果来要求自己，更多的关注过程的合理性，分析自己思路上存在的问题，知其然知其所以然。学会表达，也学会更好的表达。在网上找了一大堆的方案，最后还是选择用hexo 主题yilia ，博客搭建其实并没有想象的那么难，基于node的页面静态化，以及yml配置，基于markdown的文章编辑形式，让编写也变得容易上手的多，推荐一款在线的markdown编辑器marxi，当然有道云笔记的markdown编辑器也是很好用的，图像化的界面更容易上手。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]